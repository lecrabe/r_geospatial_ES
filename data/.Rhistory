packages <- function(x){
x <- as.character(match.call()[[2]])
if (!require(x,character.only=TRUE)){
install.packages(pkgs=x,repos="http://cran.r-project.org")
require(x,character.only=TRUE)
}
}
#############################################################a#############################
# Installacion de paquetes necessarios
# Actualizado 2017/07/26
# remi.dannunzio@fao.org
##########################################################################################
packages <- function(x){
x <- as.character(match.call()[[2]])
if (!require(x,character.only=TRUE)){
install.packages(pkgs=x,repos="http://cran.r-project.org")
require(x,character.only=TRUE)
}
}
## Packages for geospatial data handling
packages(raster)
packages(rgeos)
packages(rgdal)
packages(foreign)
## Packages for data table handling
packages(dplyr)
setwd("/media/dannunzio/OSDisk/Users/dannunzio/Documents/R/formation_geospatiale/espanol/data/")
raster <- raster("raster/bioko_uso_suelos.tif")
poly   <- readOGR(dsn="vector/gaul_livel1.shp",
layer="gaul_livel1")
points <- readOGR(dsn="vector/puntos_systematicos.shp",
layer="puntos_systematicos")
### Leer una tabla: "<-" y "read.csv"
df    <- read.csv("tablas/BIOKO_collectedData_earthaa_bioko_CE_2017_04_02_on_070417_114427_CSV.csv")
areas <- read.csv("tablas/sampling_bioko_r.csv")
### Resumen de tablas: "str"
str(df)
str(areas)
### Veer las primeras lineas: "head"
head(areas)
head(df,2)
### Nombre de columnas: "names"
names(df)
### Extraer una columna: "$"
areas$map_area
### Clase de un objecto: "class"
class(df$map_class)
### Valores unicas de un vector: "unique"
unique(df$map_class)
### Valores unicas como factores: "levels"
levels(df$map_class)
### Changer le type d'une variable: fonction "as.XXXXX"
### NB: plusieurs fonctions imbriqu?es, l'indentation est automatique
(legend <- levels(as.factor(df$map_class)
)
)
### Cuantos elementos de cada clase: "table"
table(df$map_class)
### Tabla pivotal
matrix <- table(df$map_class,df$ref_class)
matrix
### Addicionar: "sum"
sum(areas$map_area)
### Extraer un elemento / una linea / una columna: "[,]"
areas[4,]
areas[areas$map_code > 20,]
areas[,"map_area"]
areas[areas$map_edited_class == "1_bosque","map_code"]
areas[areas$map_code==1,]$map_area
### Matriz de proporciones
matrix_w <- matrix
for(i in 1:length(legend)){
for(j in 1:length(legend)){
matrix_w[i,j] <- matrix[i,j]/
sum(matrix[i,])*
areas[areas$map_code==legend[i],]$map_area/
sum(areas$map_area)
}
}
### Matriz de error standard
matrix_se<-matrix
for(i in 1:length(legend)){
for(j in 1:length(legend)){
matrix_se[i,j]<-
(areas[areas$map_code==legend[i],]$map_area/sum(areas$map_area))^2*
matrix[i,j]/
sum(matrix[i,])*
(1-matrix[i,j]/sum(matrix[i,]))/
(sum(matrix[i,])-1)
}
}
### Juego de datos de sintesis
confusion<-data.frame(matrix(nrow=length(legend),ncol=9))
names(confusion)<-c("class","code","Pa","PaW","Ua","area","area_adj","se","ci")
### cambiar cada linea de la base de datos
for(i in 1:length(legend)){
confusion[i,]$class    <- areas[areas$map_code==legend[i],]$map_edited_class
confusion[i,]$code     <- areas[areas$map_code==legend[i],]$map_code
confusion[i,]$Pa       <- matrix[i,i]/sum(matrix[,i])
confusion[i,]$Ua       <- matrix[i,i]/sum(matrix[i,])
confusion[i,]$PaW      <- matrix_w[i,i]/sum(matrix_w[,i])
confusion[i,]$area_adj <- sum(matrix_w[,i])*sum(areas$map_area)
confusion[i,]$area     <- areas[areas$map_code==legend[i],]$map_area
confusion[i,]$se       <- sqrt(sum(matrix_se[,i]))*sum(areas$map_area)
confusion[i,]$ci       <- confusion[i,]$se*1.96
}
### Veer resultados
confusion
matrix
### Exportar resultados CSV
write.csv(file="tablas/matrix_confusion.csv",matrix,row.names=T)
### Hacer grafico con intervalos de confianza
library(ggplot2)
confusion$ci      <- as.numeric(confusion$ci)
confusion$area_adj<- as.numeric(confusion$area_adj)
### Grafico simple
avg.plot <- ggplot(data=confusion,aes(x=class,y=area_adj))
### Veer el grafico
avg.plot+geom_bar(stat="identity",fill="darkgrey")
### Borrar la zona grafica
dev.off()
### Grafico con intervalos de confianza
avg.plot +
geom_bar(stat="identity",fill="darkgrey")+
geom_errorbar(aes(ymax=area_adj+ci, ymin=area_adj-ci))+
theme_bw()
##########################################################################################
##################  M?dulo de creaci?n de cuadr?cula, la extracci?n de informaci?n #######
##########################################################################################
# Puntos cubiertos:
# - leer un archivo de trama
# - crear una cuadr?cula de puntos
# - extraer informaci?n
# - seleccionar un subconjunto de datos
# - exportaci?n de resultados en formato de vectores
#############################################################a#############################
# Actualizado 2017/07/25
# remi.dannunzio@fao.org
##########################################################################################
##########################################################################################
################## Options de base, paquets
##########################################################################################
options(stringsAsFactors=FALSE)
# Cambiar el camino
# setwd("C:/Users/dannunzio/Documents/countries/congo_brazza/formation_R/module_1/")
getwd()
library(rgdal)
library(raster)
### Leer un raster: "raster"
raster <- raster("raster/bioko_uso_suelos.tif")
str(raster)
extent(raster)
# ######### Crear un extracto : "extent" y "crop"
e    <- extent(8.5,8.6,3.2,3.6)
rast <- crop(raster,e)
######### Visualizar un raster : "plot"
plot(rast)
rast <- raster
# ######### Puntos aleatorios sobre un raster: "sampleRandom"
tmp <- sampleRandom(rast,1000,xy=TRUE)
# ######### Convertir en un data frame: "data.frame"
my_sample <- data.frame(tmp)
# ######### Cambiar nombre de columnas
names(my_sample) <- c("x_coord","y_coord","value")
str(my_sample)
# ######### Extraer latitude y longitude
x<-my_sample$x_coord
y<-my_sample$y_coord
# ######### Visualizar puntos: "plot"
plot(x,y)
# ######### Borrar grafico
dev.off()
# ######### Creer un marco vacio
plot(my_sample$x_coord,my_sample$y_coord,
type="n",xlab="longitude",ylab="latitude")
# ######### Visualizar un raster : "rasterImage"
rasterImage(as.raster(rast),xmin(rast),ymin(rast),xmax(rast),ymax(rast))
# ######### Visualizar un raster : "plot"
class <-c(0,1,2,3,4,5)
cols <- c("black","grey","lightgreen","darkgreen","blue","green")
plot(rast,col=cols,breaks=class)
# ######### Anadir puntos en un grafico: "points"
points(my_sample$x_coord,my_sample$y_coord,col="yellow")
# ######### Crear un identificador unico, numero de linea: "row"
my_sample$id <- row(my_sample)[,1]
head(my_sample)
# ######### Operador logico "differente de" :  "!="
list_logic <- my_sample$value != 0
head(list_logic)
# ######### Crear un base de datos
in_country <- my_sample[list_logic,]
points(in_country$x_coord,in_country$y_coord,col="grey")
# ######### Distribucion de valores por puntos : "table"
table(in_country$value)
# ######### Seleccionar un muestreo: "sample"
pts_FP <- my_sample[
sample(my_sample[
my_sample$value==1,]$id,5)
,]
# ######### Anadir puntos en el grafico
points(pts_FP$x_coord,pts_FP$y_coord,col="red",pch=19)
# ######### Convertir pixeles en puntos: "rasterToPoints"
start <- Sys.time()
rast_PP <- rasterToPoints(rast,
fun=function(rast){rast==3})
Sys.time()-start
# ######### Convertir en data.frame
df_pts_PP        <-  as.data.frame(rast_PP)
names(df_pts_PP) <- c("x_coord","y_coord","value")
df_pts_PP$id     <- row(df_pts_PP)[,1]
# ######### Seleccionar 50 puntos de perdidas
pts_PP<-df_pts_PP[sample(df_pts_PP$id,50),]
# ######### Visualizar estos puntos de perdidas
points(pts_PP$x_coord,pts_PP$y_coord,col="red",pch=19)
# ######### Combinar 2 juegos de datos: "rbind"
mes_points <- rbind(pts_FP,pts_PP)
# ######### Verificar distribuccion de puntos por valores
table(mes_points$value)
# ######### Convertir en un formato vector: "SpatialPointsDataFrame"
sp_df<-SpatialPointsDataFrame(
coords = mes_points[,c(1,2)],
data   = data.frame(mes_points[,c(4,3)]),
proj4string=CRS("+proj=longlat +datum=WGS84")
)
# ######### Exportar en KML
writeOGR(obj=sp_df,dsn="vector/mis_points.kml",layer="mis_points",driver = "KML")
df     <- read.dbf("vector/GNQ_contour_geo_buffer005.dbf")
poly_admin <- readOGR(dsn="vector/GNQ_contour_geo_buffer005.shp",
layer="GNQ_contour_geo_buffer005")
point_admin <- readOGR(dsn="vector/mis_points.shp",
layer="mis_points")
writeOGR(obj=sp_df,dsn="vector/mis_points.shp",layer="mis_points",driver = "ESRI Shapefile")
point_admin <- readOGR(dsn="vector/mis_points.shp",
layer="mis_points")
summary(poly_admin)
names(df)[1] <- "algo"
poly_utm <- spTransform(poly_admin,CRS("+init=epsg:32631"))
my_crs <- projection(poly_utm)
my_ext <- extent(poly_utm)
extent(poly_admin)
temp   <- raster(poly_utm,resolution=1000,
ext=my_ext,crs=my_crs)
poly_utm@data$FID <- as.numeric(poly_utm@data$FID)
raster <- rasterize(x=poly_utm,y=temp,
field="FID",
background=0,fun='first',
update=TRUE)
tmp <- as.data.frame(sampleRegular(raster,100000,xy=TRUE))
points_utm <-SpatialPointsDataFrame(
coords = tmp[,c(1,2)],
data   = data.frame(tmp),
proj4string=CRS("+init=epsg:32631")
)
names(points_utm) <- c("x_coord","y_coord","val")
table(points_utm$val)
points_utm@data$id <- row(points_utm)[,1]
writeOGR(obj=points_utm,dsn="vector/puntos_systematicos.shp",layer="puntos_systematicos",driver = "ESRI Shapefile")
plot(raster)
plot(poly_utm,add=TRUE)
bioko <-poly_utm[poly_utm$FID=="1",]
bioko
plot(bioko,add=T,col="blue")
continente <-poly_utm[poly_utm$FID == 2,]
plot(continente,add=T,col="red")
union <- gUnion(continente,bioko)
plot(union)
pts_bioko <- points_utm[bioko,]
plot(pts_bioko)
poly_utm_ifn <- aggregate(x = points_utm["id"],by = poly_utm,FUN = length)
poly_utm$IFN_pts <- poly_utm_ifn@data$id
poly_utm@data
points_utm$DPT <- aggregate(x = poly_utm["FID"], by = points_utm,FUN=first)$FID
table(points_utm$DPT)
raster <- raster("raster/bioko_uso_suelos.tif")
poly   <- readOGR(dsn="vector/gaul_livel1.shp",
layer="gaul_livel1")
points <- readOGR(dsn="vector/puntos_systematicos.shp",
layer="puntos_systematicos")
table  <- read.csv("tablas/BIOKO_collectedData_earthaa_bioko_CE_2017_04_02_on_070417_114427_CSV.csv")
gfc_tc <- raster("raster/bioko_gfc_clean_nd.tif")
projection(gfc_tc)
res(gfc_tc)*111320
table$uso_suelo <- extract(raster,table[,c("location_x","location_y")])
head(table)
rcl <- data.frame(cbind(unique(gfc_tc),
c(0,1,1,1,1,2,2,2,2,rep(20,11),rep(30,11),rep(40,12),rep(50,5))
)
)
reclass <- reclassify(gfc_tc,rcl)
writeRaster(reclass,"raster/reclass.tif")
bioko <- poly[grep("Bioko Sur",poly$ADM1_NAME),]
agg <- aggregate(reclass,fact=10,fun=max)
ext <- as.data.frame(extract(agg,bioko,method="simple"))
table(ext)
(list <- poly$ADM1_NAME[grep("Bioko",poly$ADM1_NAME)])
mi_zonal <- function(dpt,raster){
table(data.frame(
extract(raster,
poly[poly$ADM1_NAME == dpt,]
)
)
)
}
sapply(list,function(x){mi_zonal(x,agg)})
